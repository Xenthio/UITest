--- /home/runner/sbox-public/engine/Sandbox.Engine/Systems/UI/Panel/Panel.Util.cs	2026-01-01 07:45:59.604934669 +0000
+++ ./src/Sandbox.UI/Panel/Panel.Util.cs	2026-01-01 07:45:47.902924524 +0000
@@ -1,52 +1,105 @@
-ï»¿
 using System.Threading;
 
 namespace Sandbox.UI;
 
+/// <summary>
+/// Utility methods and properties for Panel.
+/// Ported from s&box engine/Sandbox.Engine/Systems/UI/Panel/Panel.Util.cs
+/// </summary>
 public partial class Panel
 {
-	internal double TimeNow => PanelRealTime.TimeNow;
-	internal double TimeDelta => PanelRealTime.TimeDelta;
-
 	/// <summary>
 	/// Can be used to store random data without sub-classing the panel.
 	/// </summary>
-	[Hide]
-	public object UserData { get; set; }
-
+	public object? UserData { get; set; }
 
-	CancellationTokenSource _deleteTokenSource;
+	CancellationTokenSource? _deleteTokenSource;
 
 	/// <summary>
-	/// Get a token that is cancelled when the panel is deleted
+	/// Get a token that is cancelled when the panel is deleted.
+	/// Useful for async operations that should stop when the panel is removed.
 	/// </summary>
-	[Hide]
 	public CancellationToken DeletionToken
 	{
 		get
 		{
-			if ( IsDeleting || !IsValid )
+			if (IsDeleting || !IsValid())
 				return CancellationToken.None;
 
 			_deleteTokenSource ??= new CancellationTokenSource();
 			return _deleteTokenSource.Token;
 		}
 	}
-}
 
-static class PanelRealTime
-{
-	public static double TimeNow;
-	public static double TimeDelta;
+	/// <summary>
+	/// Invoke a method after a delay. If the panel is deleted before this delay, the method will not be called.
+	/// This is async void by design to match s&box's fire-and-forget pattern.
+	/// </summary>
+	public async void Invoke(float seconds, Action action)
+	{
+		await Task.Delay(TimeSpan.FromSeconds(seconds));
+		if (!this.IsValid()) return;
+
+		try
+		{
+			action();
+		}
+		catch (Exception e)
+		{
+			Log.Error($"Error in Invoke: {e}");
+		}
+	}
+
+	Dictionary<string, CancellationTokenSource>? invokes;
 
-	public static void Update()
+	/// <summary>
+	/// Invoke a method after a delay. If the panel is deleted before this delay, the method will not be called.
+	/// If the invoke is called while the old one is waiting, the old one will be cancelled.
+	/// This is async void by design to match s&box's fire-and-forget pattern.
+	/// </summary>
+	public async void InvokeOnce(string name, float seconds, Action action)
 	{
-		var delta = RealTime.Delta;
+		CancelInvoke(name);
 
-		// If we're running lower than 30fps, clamp it to avoid weirdness
-		delta = delta.Clamp( 0.000f, 1.0f / 30.0f );
+		var tokenSource = new CancellationTokenSource();
+		invokes ??= new Dictionary<string, CancellationTokenSource>();
+		invokes[name] = tokenSource;
 
-		TimeDelta = delta;
-		TimeNow += TimeDelta;
+		try
+		{
+			await Task.Delay(TimeSpan.FromSeconds(seconds), tokenSource.Token);
+		}
+		catch (TaskCanceledException)
+		{
+			return;
+		}
+
+		if (!this.IsValid()) return;
+
+		if (tokenSource.IsCancellationRequested)
+			return;
+
+		invokes.Remove(name);
+
+		try
+		{
+			action();
+		}
+		catch (Exception e)
+		{
+			Log.Error($"Error in InvokeOnce: {e}");
+		}
+	}
+
+	/// <summary>
+	/// Cancel a named invocation.
+	/// </summary>
+	public void CancelInvoke(string name)
+	{
+		if (invokes != null && invokes.Remove(name, out var cts))
+		{
+			cts.Cancel();
+			cts.Dispose();
+		}
 	}
 }
